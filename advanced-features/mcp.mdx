---
title: "MCP"
description: Model Control Protocol (MCP) allows you to integrate external tool providers with your Chainlit application. This enables your AI models to use tools through standardized interfaces.
---

## Overview

MCP provides a mechanism for Chainlit applications to connect to either server-sent events (SSE) or streamable HTTP based services, or command-line (stdio) based tools. Once connected, your application can discover available tools, execute them, and integrate their responses into your application's flow.

 <Card
    title="Chainlit MCP Cookbook"
    icon="github"
    href="https://github.com/Chainlit/cookbook/tree/main/mcp"
  >
    End to end cookbook example showcasing MCP tool calling with Claude.
  </Card>

<Frame caption="Connect to an MCP server">
  <video
    controls
    autoPlay
    loop
    muted
    src="https://github.com/user-attachments/assets/6119341f-fb5d-4c3f-9f10-735a74841fd6"
  />
</Frame>

### Contact us for Enterprise Ready MCP

We're working with companies to create their MCP stacks, enabling AI agents to consume their data and context in standardized ways. Fill out this [form](https://docs.google.com/forms/d/e/1FAIpQLSdObSIeIFt4nHppZ6r2rIoEe-jZRo4CqxbmRKKgb-ZsSPONnQ/viewform?usp=dialog).

## Connections Types

| WebSockets | HTTP+SSE | Streamable HTTP | stdio |
| ---------- | -------- | --------------- | ----- |
| ‚ùå         | ‚úÖ       | ‚úÖ              | ‚úÖ    |

Chainlit supports three types of MCP connections:

1. **SSE (Server-Sent Events)**: Connect to a remote service via HTTP
2. **Streamable HTTP**: Send HTTP requests to a server and receive JSON responses or connect using SSE streams
3. **stdio**: Execute a local command and communicate via standard I/O

> ‚ö†Ô∏è **Security Warning**: The stdio connection type spawns actual subprocesses on the Chainlit server. Only use this with trusted commands in controlled environments. Ensure proper validation of user inputs to prevent command injection vulnerabilities.

<Note>**Command Availability Warning**: When using the stdio connection type with commands like `npx` or `uvx`, these commands must be available on the Chainlit server where the application is running. The subprocess is executed on the server, not on the client machine.</Note>

### Server-Side Configuration (`config.toml`)

You can control which MCP connection types are enabled globally and restrict allowed stdio commands by modifying your project's `config.toml` file (usually located at the root of your project or `.chainlit/config.toml`).

Under the `[features.mcp]` section, you can configure SSE, Streamable HTTP and stdio separately:

```toml
[features]
# ... other feature flags

[features.mcp.sse]
    # Enable or disable the SSE connection type globally
    enabled = true

[features.mcp.streamable-http]
    # Enable or disable the Streamable HTTP connection type globally
    enabled = true

[features.mcp.stdio]
    # Enable or disable the stdio connection type globally
    enabled = true
    # Define an allowlist of executables for the stdio type.
    # Only the base names of executables listed here can be used.
    # This is a crucial security measure for stdio connections.
    # Example: allows running `npx ...` and `uvx ...` but blocks others.
    allowed_executables = [ "npx", "uvx" ]
```

## Setup

### 1. Register Connection Handlers

To use MCP in your Chainlit application, you need to implement the `on_mcp_connect` handler. The `on_mcp_disconnect` handler is optional but recommended for proper cleanup.

```python
import chainlit as cl
from mcp import ClientSession

@cl.on_mcp_connect
async def on_mcp_connect(connection, session: ClientSession):
    """Called when an MCP connection is established"""
    # Your connection initialization code here
    # This handler is required for MCP to work
    
@cl.on_mcp_disconnect
async def on_mcp_disconnect(name: str, session: ClientSession):
    """Called when an MCP connection is terminated"""
    # Your cleanup code here
    # This handler is optional
```

### 2. Client Configuration

The client needs to provide the connection details through the Chainlit interface. This includes:

- Connection name (unique identifier)
- Client type (`sse`, `streamable-http` or `stdio`)
- For SSE and Streamable HTTP: URL endpoint
- For stdio: Full command (e.g., `npx your-tool-package` or `uvx your-tool-package`)

<Frame caption="Adding an MCP">
  <img src="/images/add-mcp.png" />
</Frame>

## Static Server Configuration (Auto-Connection)

Instead of manually connecting MCP servers through the UI, you can configure servers to automatically connect when a chat session starts. This is useful for production deployments where you want specific MCP servers available by default.

### Configuration

Add MCP servers to your `config.toml` file under the `[features.mcp]` section:

```toml
[features.mcp]
enabled = true

# HTTP-based MCP server (e.g., web services)
[[features.mcp.servers]]
name = "csv-editor"
client = "streamable-http"
url = "http://localhost:3001/mcp"
auto_connect = true  # Automatically connect on chat start
timeout = 30

# Command-line MCP server  
[[features.mcp.servers]]
name = "local-tools"
client = "stdio"
command = "npx my-mcp-server"
auto_connect = true  # Automatically connect on chat start
timeout = 45

# Server-sent events MCP server
[[features.mcp.servers]]
name = "sse-server"
client = "sse"
url = "http://localhost:3002/sse"
auto_connect = false  # Manual connection only (default UI behavior)
timeout = 30
```

### Configuration Parameters

Each server configuration supports these parameters:

| Parameter | Required | Type | Description |
|-----------|----------|------|-------------|
| `name` | ‚úÖ | string | Unique identifier for the MCP server |
| `client` | ‚úÖ | string | Connection type: `"stdio"`, `"sse"`, or `"streamable-http"` |
| `auto_connect` | ‚ùå | boolean | Whether to connect automatically on chat start (default: `true`) |
| `timeout` | ‚ùå | integer | Connection timeout in seconds (default: `30`) |
| `url` | ‚úÖ* | string | Server URL (required for `sse` and `streamable-http`) |
| `headers` | ‚ùå | object | Additional HTTP headers (for `sse` and `streamable-http`) |
| `command` | ‚úÖ* | string | Command to execute (required for `stdio`) |

### Auto-Connection Behavior

When `auto_connect` is set to `true` (which is the default):

1. **Chat Start**: Servers are automatically connected when a new chat session begins
2. **Concurrent Connections**: Multiple servers connect simultaneously for faster startup
3. **Error Handling**: Individual connection failures don't prevent other servers from connecting
4. **Session Binding**: Connected servers are available throughout the chat session

**Connection Flow:**
```python
# Auto-connection happens before on_chat_start
@cl.on_chat_start
async def start():
    # MCP servers are already connected and available
    session = cl.context.session
    if hasattr(session, 'mcp_sessions'):
        connected_servers = list(session.mcp_sessions.keys())
        await cl.Message(f"Connected to {len(connected_servers)} MCP servers: {', '.join(connected_servers)}").send()
```

### Connection States

You can check connection status in your handlers:

```python
@cl.on_mcp_connect
async def on_mcp_connect(connection, session: ClientSession):
    """Called for each successful auto-connection"""
    await cl.Message(f"‚úÖ {connection.name} connected successfully").send()

@cl.on_chat_start
async def start():
    """Check which servers auto-connected"""
    session = cl.context.session
    mcp_sessions = getattr(session, 'mcp_sessions', {})
    
    if mcp_sessions:
        server_names = list(mcp_sessions.keys())
        await cl.Message(f"üîå Auto-connected to: {', '.join(server_names)}").send()
    else:
        await cl.Message("‚ùå No MCP servers auto-connected").send()
```

### Troubleshooting Auto-Connection

**Common Issues:**

1. **Connection Timeouts**: Increase the `timeout` value for slow-starting servers
2. **Command Not Found**: Ensure `stdio` commands are available on the server (e.g., `npx`, `uvx`)
3. **Partial Failures**: Check server logs - some servers may connect while others fail
4. **Permission Issues**: Verify `allowed_executables` includes your `stdio` commands

**Debug Information:**

Auto-connection logs are available in the Chainlit server console:
```
INFO - Auto-connecting to 3 MCP servers
INFO - Successfully auto-connected to MCP server 'csv-editor'
ERROR - Failed to auto-connect to MCP server 'local-tools': Connection timeout (30s)
INFO - MCP auto-connection completed: 2/3 successful
```

### Mixed Configuration

You can mix auto-connection servers with manual UI connections:

```toml
# These servers auto-connect
[[features.mcp.servers]]
name = "core-tools"
client = "stdio"
command = "npx core-mcp-server"
auto_connect = true

# This server requires manual connection via UI
[[features.mcp.servers]]
name = "optional-service"  
client = "streamable-http"
url = "http://localhost:3003/mcp"
auto_connect = false  # User must connect manually
```

Users can still manually connect additional servers through the UI, even when auto-connection is configured.

## Working with MCP Connections

### Retrieving Available Tools

Upon connection, you can discover the available tools provided by the MCP service:

```python
@cl.on_mcp_connect
async def on_mcp(connection, session: ClientSession):
    # List available tools
    result = await session.list_tools()
    
    # Process tool metadata
    tools = [{
        "name": t.name,
        "description": t.description,
        "input_schema": t.inputSchema,
    } for t in result.tools]
    
    # Store tools for later use
    mcp_tools = cl.user_session.get("mcp_tools", {})
    mcp_tools[connection.name] = tools
    cl.user_session.set("mcp_tools", mcp_tools)
```

### Executing Tools

You can execute tools using the MCP session:

```python
@cl.step(type="tool") 
async def call_tool(tool_use):
    tool_name = tool_use.name
    tool_input = tool_use.input
    
    # Find appropriate MCP connection for this tool
    mcp_name = find_mcp_for_tool(tool_name)
    
    # Get the MCP session
    mcp_session, _ = cl.context.session.mcp_sessions.get(mcp_name)
    
    # Call the tool
    result = await mcp_session.call_tool(tool_name, tool_input)
    
    return result
```

## Integrating with LLMs

MCP tools can be seamlessly integrated with LLMs that support tool calling:

```python
async def call_model_with_tools():
    # Get tools from all MCP connections
    mcp_tools = cl.user_session.get("mcp_tools", {})
    all_tools = [tool for connection_tools in mcp_tools.values() for tool in connection_tools]
    
    # Call your LLM with the tools
    response = await your_llm_client.call(
        messages=messages,
        tools=all_tools
    )
    
    # Handle tool calls if needed
    if response.has_tool_calls():
        # Process tool calls
        pass
        
    return response
```

## Session Management

MCP connections are managed at the session level. Each WebSocket session can have multiple named MCP connections. The connections are cleaned up when:

1. The user explicitly disconnects
2. The same connection name is reused (old connection is replaced)
3. The WebSocket session ends