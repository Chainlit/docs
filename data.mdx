---
title: Data Persistence
---

When you create a Chainlit app and interact with it, various types of data will be generated, such as chat messages, human feedback on messages, or files. Persisting and utilizing this data can be an essential aspect of your app.

By default, no data is persisted. Chainlit offers several persistence modes, each designed for different use cases.

## Local Persistence

This is the simplest way to persist data. Chats will be saved in the `.chainlit/chat.db` (SQLite database), and files will be stored in the `.chainlit/chat_files` folder. This mode does not support multiple users or authentication.

<Note>
  A working Node.js installation is required to use local mode, as it relies on
  the Prisma CLI.
</Note>

To enable local persistence, update the database field in your [config](/cloud/config) file:

```toml
[project]
database = "local"
```

## Chainlit Cloud Persistence

This is the recommended method for persisting data. Chats and files will be stored in Chainlit's cloud. This mode supports authentication through Chainlit's Auth0 and allows multiple users.

To enable Chainlit Cloud, first [create a project](/cloud/create-project). Then, update your [config](/cloud/config) file:

```toml
[project]
public = false
id = "my-project-id"
database = "cloud"
```

## Custom Persistence

Choose this option if you want to store data in your own database and file system.

<Note>Providing your own authentication system is not yet supported.</Note>

To use custom persistence, you need to create your own `Client` that extends the [BaseClient](https://github.com/Chainlit/chainlit/blob/main/src/chainlit/client/base.py) class. For reference, check the [CloudClient](https://github.com/Chainlit/chainlit/blob/main/src/chainlit/client/cloud.py) and [LocalClient](https://github.com/Chainlit/chainlit/blob/main/src/chainlit/client/local.py) implementations.

Update your [config](/cloud/config) file:

```toml
[project]
database = "custom"
```

Finally, modify your Chainlit app code to include the `client_factory` and provide your custom client.

```py
from typing import List, Literal, Dict

import chainlit as cl
from chainlit.client.base import (
    BaseClient,
    UserDict,
    ConversationDict,
    Pagination,
    ConversationFilter,
    PaginatedResponse,
    MessageDict,
    ElementDict,
)


class CustomClient(BaseClient):
    async def is_project_member(self, access_token: str) -> bool:
        raise NotImplementedError

    async def get_member_role(self, access_token: str) -> str:
        raise NotImplementedError

    async def get_project_members(self) -> List[UserDict]:
        raise NotImplementedError

    async def create_conversation(self) -> int:
        raise NotImplementedError

    async def delete_conversation(self, conversation_id: int) -> bool:
        raise NotImplementedError

    async def get_conversation(self, conversation_id: int) -> ConversationDict:
        raise NotImplementedError

    async def get_conversations(
        self, pagination: "Pagination", filter: "ConversationFilter"
    ) -> PaginatedResponse[ConversationDict]:
        raise NotImplementedError

    async def get_message(self, conversation_id: str, message_id: str) -> Dict:
        raise NotImplementedError

    async def create_message(self, variables: MessageDict) -> int:
        raise NotImplementedError

    async def update_message(self, message_id: int, variables: MessageDict) -> bool:
        raise NotImplementedError

    async def delete_message(self, message_id: int) -> bool:
        raise NotImplementedError

    async def upload_element(self, content: bytes, mime: str) -> str:
        raise NotImplementedError

    async def upsert_element(self, variables: ElementDict) -> ElementDict:
        raise NotImplementedError

    async def get_element(self, conversation_id: int, element_id: int) -> ElementDict:
        raise NotImplementedError

    async def set_human_feedback(
        self, message_id: int, feedback: Literal[-1, 0, 1]
    ) -> bool:
        raise NotImplementedError


@cl.client_factory
async def client_factory():
    return CustomClient()


@cl.on_chat_start
async def on_chat_start():
    await cl.Message("Hello").send()

```
